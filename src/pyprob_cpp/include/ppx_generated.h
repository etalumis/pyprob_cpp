// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PPX_PPX_H_
#define FLATBUFFERS_GENERATED_PPX_PPX_H_

#include "flatbuffers/flatbuffers.h"

namespace ppx {

struct Message;
struct MessageBuilder;

struct Tensor;
struct TensorBuilder;

struct Handshake;
struct HandshakeBuilder;

struct HandshakeResult;
struct HandshakeResultBuilder;

struct Run;
struct RunBuilder;

struct RunResult;
struct RunResultBuilder;

struct Sample;
struct SampleBuilder;

struct SampleResult;
struct SampleResultBuilder;

struct Observe;
struct ObserveBuilder;

struct ObserveResult;
struct ObserveResultBuilder;

struct Tag;
struct TagBuilder;

struct TagResult;
struct TagResultBuilder;

struct Reset;
struct ResetBuilder;

struct Normal;
struct NormalBuilder;

struct Uniform;
struct UniformBuilder;

struct Categorical;
struct CategoricalBuilder;

struct Poisson;
struct PoissonBuilder;

enum MessageBody {
  MessageBody_NONE = 0,
  MessageBody_Handshake = 1,
  MessageBody_HandshakeResult = 2,
  MessageBody_Run = 3,
  MessageBody_RunResult = 4,
  MessageBody_Sample = 5,
  MessageBody_SampleResult = 6,
  MessageBody_Observe = 7,
  MessageBody_ObserveResult = 8,
  MessageBody_Tag = 9,
  MessageBody_TagResult = 10,
  MessageBody_Reset = 11,
  MessageBody_MIN = MessageBody_NONE,
  MessageBody_MAX = MessageBody_Reset
};

inline const MessageBody (&EnumValuesMessageBody())[12] {
  static const MessageBody values[] = {
    MessageBody_NONE,
    MessageBody_Handshake,
    MessageBody_HandshakeResult,
    MessageBody_Run,
    MessageBody_RunResult,
    MessageBody_Sample,
    MessageBody_SampleResult,
    MessageBody_Observe,
    MessageBody_ObserveResult,
    MessageBody_Tag,
    MessageBody_TagResult,
    MessageBody_Reset
  };
  return values;
}

inline const char * const *EnumNamesMessageBody() {
  static const char * const names[13] = {
    "NONE",
    "Handshake",
    "HandshakeResult",
    "Run",
    "RunResult",
    "Sample",
    "SampleResult",
    "Observe",
    "ObserveResult",
    "Tag",
    "TagResult",
    "Reset",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageBody(MessageBody e) {
  if (flatbuffers::IsOutRange(e, MessageBody_NONE, MessageBody_Reset)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageBody()[index];
}

template<typename T> struct MessageBodyTraits {
  static const MessageBody enum_value = MessageBody_NONE;
};

template<> struct MessageBodyTraits<ppx::Handshake> {
  static const MessageBody enum_value = MessageBody_Handshake;
};

template<> struct MessageBodyTraits<ppx::HandshakeResult> {
  static const MessageBody enum_value = MessageBody_HandshakeResult;
};

template<> struct MessageBodyTraits<ppx::Run> {
  static const MessageBody enum_value = MessageBody_Run;
};

template<> struct MessageBodyTraits<ppx::RunResult> {
  static const MessageBody enum_value = MessageBody_RunResult;
};

template<> struct MessageBodyTraits<ppx::Sample> {
  static const MessageBody enum_value = MessageBody_Sample;
};

template<> struct MessageBodyTraits<ppx::SampleResult> {
  static const MessageBody enum_value = MessageBody_SampleResult;
};

template<> struct MessageBodyTraits<ppx::Observe> {
  static const MessageBody enum_value = MessageBody_Observe;
};

template<> struct MessageBodyTraits<ppx::ObserveResult> {
  static const MessageBody enum_value = MessageBody_ObserveResult;
};

template<> struct MessageBodyTraits<ppx::Tag> {
  static const MessageBody enum_value = MessageBody_Tag;
};

template<> struct MessageBodyTraits<ppx::TagResult> {
  static const MessageBody enum_value = MessageBody_TagResult;
};

template<> struct MessageBodyTraits<ppx::Reset> {
  static const MessageBody enum_value = MessageBody_Reset;
};

bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type);
bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Distribution {
  Distribution_NONE = 0,
  Distribution_Normal = 1,
  Distribution_Uniform = 2,
  Distribution_Categorical = 3,
  Distribution_Poisson = 4,
  Distribution_MIN = Distribution_NONE,
  Distribution_MAX = Distribution_Poisson
};

inline const Distribution (&EnumValuesDistribution())[5] {
  static const Distribution values[] = {
    Distribution_NONE,
    Distribution_Normal,
    Distribution_Uniform,
    Distribution_Categorical,
    Distribution_Poisson
  };
  return values;
}

inline const char * const *EnumNamesDistribution() {
  static const char * const names[6] = {
    "NONE",
    "Normal",
    "Uniform",
    "Categorical",
    "Poisson",
    nullptr
  };
  return names;
}

inline const char *EnumNameDistribution(Distribution e) {
  if (flatbuffers::IsOutRange(e, Distribution_NONE, Distribution_Poisson)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDistribution()[index];
}

template<typename T> struct DistributionTraits {
  static const Distribution enum_value = Distribution_NONE;
};

template<> struct DistributionTraits<ppx::Normal> {
  static const Distribution enum_value = Distribution_Normal;
};

template<> struct DistributionTraits<ppx::Uniform> {
  static const Distribution enum_value = Distribution_Uniform;
};

template<> struct DistributionTraits<ppx::Categorical> {
  static const Distribution enum_value = Distribution_Categorical;
};

template<> struct DistributionTraits<ppx::Poisson> {
  static const Distribution enum_value = Distribution_Poisson;
};

bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type);
bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BODY_TYPE = 4,
    VT_BODY = 6
  };
  ppx::MessageBody body_type() const {
    return static_cast<ppx::MessageBody>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const ppx::Handshake *body_as_Handshake() const {
    return body_type() == ppx::MessageBody_Handshake ? static_cast<const ppx::Handshake *>(body()) : nullptr;
  }
  const ppx::HandshakeResult *body_as_HandshakeResult() const {
    return body_type() == ppx::MessageBody_HandshakeResult ? static_cast<const ppx::HandshakeResult *>(body()) : nullptr;
  }
  const ppx::Run *body_as_Run() const {
    return body_type() == ppx::MessageBody_Run ? static_cast<const ppx::Run *>(body()) : nullptr;
  }
  const ppx::RunResult *body_as_RunResult() const {
    return body_type() == ppx::MessageBody_RunResult ? static_cast<const ppx::RunResult *>(body()) : nullptr;
  }
  const ppx::Sample *body_as_Sample() const {
    return body_type() == ppx::MessageBody_Sample ? static_cast<const ppx::Sample *>(body()) : nullptr;
  }
  const ppx::SampleResult *body_as_SampleResult() const {
    return body_type() == ppx::MessageBody_SampleResult ? static_cast<const ppx::SampleResult *>(body()) : nullptr;
  }
  const ppx::Observe *body_as_Observe() const {
    return body_type() == ppx::MessageBody_Observe ? static_cast<const ppx::Observe *>(body()) : nullptr;
  }
  const ppx::ObserveResult *body_as_ObserveResult() const {
    return body_type() == ppx::MessageBody_ObserveResult ? static_cast<const ppx::ObserveResult *>(body()) : nullptr;
  }
  const ppx::Tag *body_as_Tag() const {
    return body_type() == ppx::MessageBody_Tag ? static_cast<const ppx::Tag *>(body()) : nullptr;
  }
  const ppx::TagResult *body_as_TagResult() const {
    return body_type() == ppx::MessageBody_TagResult ? static_cast<const ppx::TagResult *>(body()) : nullptr;
  }
  const ppx::Reset *body_as_Reset() const {
    return body_type() == ppx::MessageBody_Reset ? static_cast<const ppx::Reset *>(body()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyMessageBody(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ppx::Handshake *Message::body_as<ppx::Handshake>() const {
  return body_as_Handshake();
}

template<> inline const ppx::HandshakeResult *Message::body_as<ppx::HandshakeResult>() const {
  return body_as_HandshakeResult();
}

template<> inline const ppx::Run *Message::body_as<ppx::Run>() const {
  return body_as_Run();
}

template<> inline const ppx::RunResult *Message::body_as<ppx::RunResult>() const {
  return body_as_RunResult();
}

template<> inline const ppx::Sample *Message::body_as<ppx::Sample>() const {
  return body_as_Sample();
}

template<> inline const ppx::SampleResult *Message::body_as<ppx::SampleResult>() const {
  return body_as_SampleResult();
}

template<> inline const ppx::Observe *Message::body_as<ppx::Observe>() const {
  return body_as_Observe();
}

template<> inline const ppx::ObserveResult *Message::body_as<ppx::ObserveResult>() const {
  return body_as_ObserveResult();
}

template<> inline const ppx::Tag *Message::body_as<ppx::Tag>() const {
  return body_as_Tag();
}

template<> inline const ppx::TagResult *Message::body_as<ppx::TagResult>() const {
  return body_as_TagResult();
}

template<> inline const ppx::Reset *Message::body_as<ppx::Reset>() const {
  return body_as_Reset();
}

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_type(ppx::MessageBody body_type) {
    fbb_.AddElement<uint8_t>(Message::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(flatbuffers::Offset<void> body) {
    fbb_.AddOffset(Message::VT_BODY, body);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    ppx::MessageBody body_type = ppx::MessageBody_NONE,
    flatbuffers::Offset<void> body = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4,
    VT_SHAPE = 6
  };
  const flatbuffers::Vector<double> *data() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DATA);
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *data = nullptr,
    const std::vector<int32_t> *shape = nullptr) {
  auto data__ = data ? _fbb.CreateVector<double>(*data) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return ppx::CreateTensor(
      _fbb,
      data__,
      shape__);
}

struct Handshake FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_NAME = 4
  };
  const flatbuffers::String *system_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SYSTEM_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_NAME) &&
           verifier.VerifyString(system_name()) &&
           verifier.EndTable();
  }
};

struct HandshakeBuilder {
  typedef Handshake Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_system_name(flatbuffers::Offset<flatbuffers::String> system_name) {
    fbb_.AddOffset(Handshake::VT_SYSTEM_NAME, system_name);
  }
  explicit HandshakeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeBuilder &operator=(const HandshakeBuilder &);
  flatbuffers::Offset<Handshake> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Handshake>(end);
    return o;
  }
};

inline flatbuffers::Offset<Handshake> CreateHandshake(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> system_name = 0) {
  HandshakeBuilder builder_(_fbb);
  builder_.add_system_name(system_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Handshake> CreateHandshakeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *system_name = nullptr) {
  auto system_name__ = system_name ? _fbb.CreateString(system_name) : 0;
  return ppx::CreateHandshake(
      _fbb,
      system_name__);
}

struct HandshakeResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HandshakeResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYSTEM_NAME = 4,
    VT_MODEL_NAME = 6
  };
  const flatbuffers::String *system_name() const {
    return GetPointer<const flatbuffers::String *>(VT_SYSTEM_NAME);
  }
  const flatbuffers::String *model_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYSTEM_NAME) &&
           verifier.VerifyString(system_name()) &&
           VerifyOffset(verifier, VT_MODEL_NAME) &&
           verifier.VerifyString(model_name()) &&
           verifier.EndTable();
  }
};

struct HandshakeResultBuilder {
  typedef HandshakeResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_system_name(flatbuffers::Offset<flatbuffers::String> system_name) {
    fbb_.AddOffset(HandshakeResult::VT_SYSTEM_NAME, system_name);
  }
  void add_model_name(flatbuffers::Offset<flatbuffers::String> model_name) {
    fbb_.AddOffset(HandshakeResult::VT_MODEL_NAME, model_name);
  }
  explicit HandshakeResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HandshakeResultBuilder &operator=(const HandshakeResultBuilder &);
  flatbuffers::Offset<HandshakeResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HandshakeResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<HandshakeResult> CreateHandshakeResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> system_name = 0,
    flatbuffers::Offset<flatbuffers::String> model_name = 0) {
  HandshakeResultBuilder builder_(_fbb);
  builder_.add_model_name(model_name);
  builder_.add_system_name(system_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<HandshakeResult> CreateHandshakeResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *system_name = nullptr,
    const char *model_name = nullptr) {
  auto system_name__ = system_name ? _fbb.CreateString(system_name) : 0;
  auto model_name__ = model_name ? _fbb.CreateString(model_name) : 0;
  return ppx::CreateHandshakeResult(
      _fbb,
      system_name__,
      model_name__);
}

struct Run FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RunBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RunBuilder {
  typedef Run Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RunBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RunBuilder &operator=(const RunBuilder &);
  flatbuffers::Offset<Run> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Run>(end);
    return o;
  }
};

inline flatbuffers::Offset<Run> CreateRun(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RunBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RunResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RunResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  const ppx::Tensor *result() const {
    return GetPointer<const ppx::Tensor *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct RunResultBuilder {
  typedef RunResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(flatbuffers::Offset<ppx::Tensor> result) {
    fbb_.AddOffset(RunResult::VT_RESULT, result);
  }
  explicit RunResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RunResultBuilder &operator=(const RunResultBuilder &);
  flatbuffers::Offset<RunResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RunResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<RunResult> CreateRunResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppx::Tensor> result = 0) {
  RunResultBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct Sample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SampleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_NAME = 6,
    VT_DISTRIBUTION_TYPE = 8,
    VT_DISTRIBUTION = 10,
    VT_CONTROL = 12,
    VT_REPLACE = 14
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  ppx::Distribution distribution_type() const {
    return static_cast<ppx::Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const ppx::Normal *distribution_as_Normal() const {
    return distribution_type() == ppx::Distribution_Normal ? static_cast<const ppx::Normal *>(distribution()) : nullptr;
  }
  const ppx::Uniform *distribution_as_Uniform() const {
    return distribution_type() == ppx::Distribution_Uniform ? static_cast<const ppx::Uniform *>(distribution()) : nullptr;
  }
  const ppx::Categorical *distribution_as_Categorical() const {
    return distribution_type() == ppx::Distribution_Categorical ? static_cast<const ppx::Categorical *>(distribution()) : nullptr;
  }
  const ppx::Poisson *distribution_as_Poisson() const {
    return distribution_type() == ppx::Distribution_Poisson ? static_cast<const ppx::Poisson *>(distribution()) : nullptr;
  }
  bool control() const {
    return GetField<uint8_t>(VT_CONTROL, 1) != 0;
  }
  bool replace() const {
    return GetField<uint8_t>(VT_REPLACE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           VerifyField<uint8_t>(verifier, VT_CONTROL) &&
           VerifyField<uint8_t>(verifier, VT_REPLACE) &&
           verifier.EndTable();
  }
};

template<> inline const ppx::Normal *Sample::distribution_as<ppx::Normal>() const {
  return distribution_as_Normal();
}

template<> inline const ppx::Uniform *Sample::distribution_as<ppx::Uniform>() const {
  return distribution_as_Uniform();
}

template<> inline const ppx::Categorical *Sample::distribution_as<ppx::Categorical>() const {
  return distribution_as_Categorical();
}

template<> inline const ppx::Poisson *Sample::distribution_as<ppx::Poisson>() const {
  return distribution_as_Poisson();
}

struct SampleBuilder {
  typedef Sample Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Sample::VT_ADDRESS, address);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Sample::VT_NAME, name);
  }
  void add_distribution_type(ppx::Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(Sample::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(Sample::VT_DISTRIBUTION, distribution);
  }
  void add_control(bool control) {
    fbb_.AddElement<uint8_t>(Sample::VT_CONTROL, static_cast<uint8_t>(control), 1);
  }
  void add_replace(bool replace) {
    fbb_.AddElement<uint8_t>(Sample::VT_REPLACE, static_cast<uint8_t>(replace), 0);
  }
  explicit SampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SampleBuilder &operator=(const SampleBuilder &);
  flatbuffers::Offset<Sample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sample>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sample> CreateSample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ppx::Distribution distribution_type = ppx::Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    bool control = true,
    bool replace = false) {
  SampleBuilder builder_(_fbb);
  builder_.add_distribution(distribution);
  builder_.add_name(name);
  builder_.add_address(address);
  builder_.add_replace(replace);
  builder_.add_control(control);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sample> CreateSampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *name = nullptr,
    ppx::Distribution distribution_type = ppx::Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    bool control = true,
    bool replace = false) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateSample(
      _fbb,
      address__,
      name__,
      distribution_type,
      distribution,
      control,
      replace);
}

struct SampleResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SampleResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4
  };
  const ppx::Tensor *result() const {
    return GetPointer<const ppx::Tensor *>(VT_RESULT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESULT) &&
           verifier.VerifyTable(result()) &&
           verifier.EndTable();
  }
};

struct SampleResultBuilder {
  typedef SampleResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(flatbuffers::Offset<ppx::Tensor> result) {
    fbb_.AddOffset(SampleResult::VT_RESULT, result);
  }
  explicit SampleResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SampleResultBuilder &operator=(const SampleResultBuilder &);
  flatbuffers::Offset<SampleResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SampleResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<SampleResult> CreateSampleResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppx::Tensor> result = 0) {
  SampleResultBuilder builder_(_fbb);
  builder_.add_result(result);
  return builder_.Finish();
}

struct Observe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObserveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_NAME = 6,
    VT_DISTRIBUTION_TYPE = 8,
    VT_DISTRIBUTION = 10,
    VT_VALUE = 12
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  ppx::Distribution distribution_type() const {
    return static_cast<ppx::Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const ppx::Normal *distribution_as_Normal() const {
    return distribution_type() == ppx::Distribution_Normal ? static_cast<const ppx::Normal *>(distribution()) : nullptr;
  }
  const ppx::Uniform *distribution_as_Uniform() const {
    return distribution_type() == ppx::Distribution_Uniform ? static_cast<const ppx::Uniform *>(distribution()) : nullptr;
  }
  const ppx::Categorical *distribution_as_Categorical() const {
    return distribution_type() == ppx::Distribution_Categorical ? static_cast<const ppx::Categorical *>(distribution()) : nullptr;
  }
  const ppx::Poisson *distribution_as_Poisson() const {
    return distribution_type() == ppx::Distribution_Poisson ? static_cast<const ppx::Poisson *>(distribution()) : nullptr;
  }
  const ppx::Tensor *value() const {
    return GetPointer<const ppx::Tensor *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

template<> inline const ppx::Normal *Observe::distribution_as<ppx::Normal>() const {
  return distribution_as_Normal();
}

template<> inline const ppx::Uniform *Observe::distribution_as<ppx::Uniform>() const {
  return distribution_as_Uniform();
}

template<> inline const ppx::Categorical *Observe::distribution_as<ppx::Categorical>() const {
  return distribution_as_Categorical();
}

template<> inline const ppx::Poisson *Observe::distribution_as<ppx::Poisson>() const {
  return distribution_as_Poisson();
}

struct ObserveBuilder {
  typedef Observe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Observe::VT_ADDRESS, address);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Observe::VT_NAME, name);
  }
  void add_distribution_type(ppx::Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(Observe::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(Observe::VT_DISTRIBUTION, distribution);
  }
  void add_value(flatbuffers::Offset<ppx::Tensor> value) {
    fbb_.AddOffset(Observe::VT_VALUE, value);
  }
  explicit ObserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObserveBuilder &operator=(const ObserveBuilder &);
  flatbuffers::Offset<Observe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Observe>(end);
    return o;
  }
};

inline flatbuffers::Offset<Observe> CreateObserve(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    ppx::Distribution distribution_type = ppx::Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    flatbuffers::Offset<ppx::Tensor> value = 0) {
  ObserveBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_distribution(distribution);
  builder_.add_name(name);
  builder_.add_address(address);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Observe> CreateObserveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *name = nullptr,
    ppx::Distribution distribution_type = ppx::Distribution_NONE,
    flatbuffers::Offset<void> distribution = 0,
    flatbuffers::Offset<ppx::Tensor> value = 0) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateObserve(
      _fbb,
      address__,
      name__,
      distribution_type,
      distribution,
      value);
}

struct ObserveResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObserveResultBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ObserveResultBuilder {
  typedef ObserveResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ObserveResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObserveResultBuilder &operator=(const ObserveResultBuilder &);
  flatbuffers::Offset<ObserveResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObserveResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObserveResult> CreateObserveResult(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ObserveResultBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Tag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_NAME = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const ppx::Tensor *value() const {
    return GetPointer<const ppx::Tensor *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct TagBuilder {
  typedef Tag Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Tag::VT_ADDRESS, address);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tag::VT_NAME, name);
  }
  void add_value(flatbuffers::Offset<ppx::Tensor> value) {
    fbb_.AddOffset(Tag::VT_VALUE, value);
  }
  explicit TagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagBuilder &operator=(const TagBuilder &);
  flatbuffers::Offset<Tag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tag>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tag> CreateTag(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<ppx::Tensor> value = 0) {
  TagBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_address(address);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tag> CreateTagDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    const char *name = nullptr,
    flatbuffers::Offset<ppx::Tensor> value = 0) {
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ppx::CreateTag(
      _fbb,
      address__,
      name__,
      value);
}

struct TagResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TagResultBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TagResultBuilder {
  typedef TagResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TagResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TagResultBuilder &operator=(const TagResultBuilder &);
  flatbuffers::Offset<TagResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TagResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<TagResult> CreateTagResult(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TagResultBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Reset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResetBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ResetBuilder {
  typedef Reset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ResetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResetBuilder &operator=(const ResetBuilder &);
  flatbuffers::Offset<Reset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reset>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reset> CreateReset(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ResetBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Normal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NormalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEAN = 4,
    VT_STDDEV = 6
  };
  const ppx::Tensor *mean() const {
    return GetPointer<const ppx::Tensor *>(VT_MEAN);
  }
  const ppx::Tensor *stddev() const {
    return GetPointer<const ppx::Tensor *>(VT_STDDEV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyTable(mean()) &&
           VerifyOffset(verifier, VT_STDDEV) &&
           verifier.VerifyTable(stddev()) &&
           verifier.EndTable();
  }
};

struct NormalBuilder {
  typedef Normal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mean(flatbuffers::Offset<ppx::Tensor> mean) {
    fbb_.AddOffset(Normal::VT_MEAN, mean);
  }
  void add_stddev(flatbuffers::Offset<ppx::Tensor> stddev) {
    fbb_.AddOffset(Normal::VT_STDDEV, stddev);
  }
  explicit NormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalBuilder &operator=(const NormalBuilder &);
  flatbuffers::Offset<Normal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Normal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Normal> CreateNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppx::Tensor> mean = 0,
    flatbuffers::Offset<ppx::Tensor> stddev = 0) {
  NormalBuilder builder_(_fbb);
  builder_.add_stddev(stddev);
  builder_.add_mean(mean);
  return builder_.Finish();
}

struct Uniform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniformBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOW = 4,
    VT_HIGH = 6
  };
  const ppx::Tensor *low() const {
    return GetPointer<const ppx::Tensor *>(VT_LOW);
  }
  const ppx::Tensor *high() const {
    return GetPointer<const ppx::Tensor *>(VT_HIGH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LOW) &&
           verifier.VerifyTable(low()) &&
           VerifyOffset(verifier, VT_HIGH) &&
           verifier.VerifyTable(high()) &&
           verifier.EndTable();
  }
};

struct UniformBuilder {
  typedef Uniform Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_low(flatbuffers::Offset<ppx::Tensor> low) {
    fbb_.AddOffset(Uniform::VT_LOW, low);
  }
  void add_high(flatbuffers::Offset<ppx::Tensor> high) {
    fbb_.AddOffset(Uniform::VT_HIGH, high);
  }
  explicit UniformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformBuilder &operator=(const UniformBuilder &);
  flatbuffers::Offset<Uniform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uniform>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uniform> CreateUniform(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppx::Tensor> low = 0,
    flatbuffers::Offset<ppx::Tensor> high = 0) {
  UniformBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  return builder_.Finish();
}

struct Categorical FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CategoricalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROBS = 4
  };
  const ppx::Tensor *probs() const {
    return GetPointer<const ppx::Tensor *>(VT_PROBS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROBS) &&
           verifier.VerifyTable(probs()) &&
           verifier.EndTable();
  }
};

struct CategoricalBuilder {
  typedef Categorical Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_probs(flatbuffers::Offset<ppx::Tensor> probs) {
    fbb_.AddOffset(Categorical::VT_PROBS, probs);
  }
  explicit CategoricalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CategoricalBuilder &operator=(const CategoricalBuilder &);
  flatbuffers::Offset<Categorical> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Categorical>(end);
    return o;
  }
};

inline flatbuffers::Offset<Categorical> CreateCategorical(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppx::Tensor> probs = 0) {
  CategoricalBuilder builder_(_fbb);
  builder_.add_probs(probs);
  return builder_.Finish();
}

struct Poisson FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PoissonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATE = 4
  };
  const ppx::Tensor *rate() const {
    return GetPointer<const ppx::Tensor *>(VT_RATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RATE) &&
           verifier.VerifyTable(rate()) &&
           verifier.EndTable();
  }
};

struct PoissonBuilder {
  typedef Poisson Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rate(flatbuffers::Offset<ppx::Tensor> rate) {
    fbb_.AddOffset(Poisson::VT_RATE, rate);
  }
  explicit PoissonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoissonBuilder &operator=(const PoissonBuilder &);
  flatbuffers::Offset<Poisson> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Poisson>(end);
    return o;
  }
};

inline flatbuffers::Offset<Poisson> CreatePoisson(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ppx::Tensor> rate = 0) {
  PoissonBuilder builder_(_fbb);
  builder_.add_rate(rate);
  return builder_.Finish();
}

inline bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type) {
  switch (type) {
    case MessageBody_NONE: {
      return true;
    }
    case MessageBody_Handshake: {
      auto ptr = reinterpret_cast<const ppx::Handshake *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_HandshakeResult: {
      auto ptr = reinterpret_cast<const ppx::HandshakeResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Run: {
      auto ptr = reinterpret_cast<const ppx::Run *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_RunResult: {
      auto ptr = reinterpret_cast<const ppx::RunResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Sample: {
      auto ptr = reinterpret_cast<const ppx::Sample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_SampleResult: {
      auto ptr = reinterpret_cast<const ppx::SampleResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Observe: {
      auto ptr = reinterpret_cast<const ppx::Observe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_ObserveResult: {
      auto ptr = reinterpret_cast<const ppx::ObserveResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Tag: {
      auto ptr = reinterpret_cast<const ppx::Tag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_TagResult: {
      auto ptr = reinterpret_cast<const ppx::TagResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody_Reset: {
      auto ptr = reinterpret_cast<const ppx::Reset *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageBody(
        verifier,  values->Get(i), types->GetEnum<MessageBody>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type) {
  switch (type) {
    case Distribution_NONE: {
      return true;
    }
    case Distribution_Normal: {
      auto ptr = reinterpret_cast<const ppx::Normal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution_Uniform: {
      auto ptr = reinterpret_cast<const ppx::Uniform *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution_Categorical: {
      auto ptr = reinterpret_cast<const ppx::Categorical *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution_Poisson: {
      auto ptr = reinterpret_cast<const ppx::Poisson *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDistribution(
        verifier,  values->Get(i), types->GetEnum<Distribution>(i))) {
      return false;
    }
  }
  return true;
}

inline const ppx::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<ppx::Message>(buf);
}

inline const ppx::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ppx::Message>(buf);
}

inline const char *MessageIdentifier() {
  return "PPXF";
}

inline bool MessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier());
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ppx::Message>(MessageIdentifier());
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ppx::Message>(MessageIdentifier());
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppx::Message> root) {
  fbb.Finish(root, MessageIdentifier());
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ppx::Message> root) {
  fbb.FinishSizePrefixed(root, MessageIdentifier());
}

}  // namespace ppx

#endif  // FLATBUFFERS_GENERATED_PPX_PPX_H_
